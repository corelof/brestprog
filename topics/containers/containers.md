---
layout: topic
title: "Контейнеры: map, set, multiset"
permalink: topics/containers/
---

## std::map (ассоциативный массив) ##

Ассоциативный массив - структура данных, которая позволяет нам выполнять различные операции
над парами (ключ, значение). В С++ ассоциативные массивы представлены в стандартной библиотеке
классом `std::map`.

### Ассимтотическая сложность ###

* Вставка ключа, обновление значения ключа - $$O(logN)$$
* Удаление ключа - $$O(logN)$$
* Поиск по ключу - $$O(logN)$$
* Поиск по значению - $$O(N)$$(необходимо итерироваться, пока не будет найдено необходимое значение).
* Количество различных ключей на текущий момент - $$O(1)$$

Стоит помнить, что асимптотическая сложность -- по сути теоретический параметр, а на практике
разница между временем работы разных операций одинаковой сложности может быть очень ощутима.
В случае `map`, операции сложностью $$O(\log N)$$ работают гораздо медленнее, чем, например,
бинарный поиск, и при решении задач об этом необходимо помнить.

### Использование ###

Решим простую задачу, используя `map`:

Дана строка $$s$$ из $$n$$ слов. Необходимо вывести наиболее часто встречающееся слово и количество его вхождений в стрку.
{% highlight cpp linenos %}
#include <bits/stdc++.h>

using namespace std;

//Объявление карты: map<t1, t2>.
//t1 - тип ключа
//t2 - тип значения
map<string, int> cnt;
int n;
string s;

//compare определяет слово с большим числом вхождений
pair<string, int> compare (pair<string, int> w1, pair<string, int> w2)
{
	if (w1.second >= w2.second)
		return w1;
	return w2;
}

int main ()
{
	cin >> n;
	for (int i = 0; i < n; i ++)
	{
		cin >> s;
		//Подсчет количества вхождений каждого слова
		cnt[s] ++;
	}
	pair<string, int> mostCommontWord = *cnt.begin ();
	//Итерирование по карте:
	//обход производится в порядке возрастания ключей
	for (pair<string, int> i : cnt)
		mostCommontWord = compare (mostCommontWord, i);
	//Вывод ключа, т.е. самого слова
	cout << mostCommontWord.first << ' ';
	//Вывод числа вхождений
	cout << mostCommontWord.second << endl;
}
{% endhighlight %}

## Множества ##

Множество(`set`) - структура данных, предназначенная для управления элементами по значению.

Свойства множеств, которые важны для решения олимпиадных задач:
* Элементы во множестве хранятся в отсортированном по возрастанию виде.
* Множество хранит только одно вхождения любого элемента(в отличие от мультимножества).

Большинство операций с множествами с `С++` имеют сложность порядка $$O(logN)$$ операций, однако так же не стоит забывать про константу, которая эквивалентна константе `map`.

### Основные операции и ассимптотическая сложность ###

* Вставка элемента - $$O(logN)$$
* Поиск элемента - $$O(logN)$$
* Удаление элемента - $$O(logN)$$
* Текущий размер(количество элементов) - $$O(1)$$

### Использование ###

Решим простую задачу, используя множество:

Дан массив $$a$$ из $$n(n \le 10^5)$$ чисел $$a_i(a_i \le 10^9)$$. Необходимо вывести количество различных элементов в данном массиве.

{% highlight cpp linenos %}
#include <bits/stdc++.h>

using namespace std;

//Объявление множества:
//set<type>, где type - тип элементов
set<int> s;

int main(){
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        //Вставка элементов массива во множество
		s.insert(x);
	}
	//Вывод размера множества,
	//т.е. количества различных элементов в нем
    cout << s.size();
}
{% endhighlight %}

## Мультимножества ##

Мультимножество(`multiset`) обладает теми же свойствами, что и обычное множество, за исключением того, что один элемент может входить в мультимножество несколько раз.

## Структуры на хэш-таблицах

Для всех описанных выше структур данных существуют их аналоги с префиксом unordered_(неупорядоченный). Отличие их состоит в том, что они реализованы с использованием хэш-таблиц, а значит ассимтотическая сложность операций с ними порядка O(1)(в среднем), однако константа еще больше, чем в упорядоченных структурах, указанных выше. Неупорядоченность проявляется в том, например, что элементы `unordered_map` при итерировании не обходятся в порядке возрастания ключей. Это стоит учитывать при решении задач, где лишний логарифм в ассимптотике может быть критичен.

## Подключение библиотек

Если вы по какой-то причине не используете ```bits/stdc++.h```, то все упомянутые выше структуры данных находятся в одноименных библиотеках. Т.е. для использования ```map``` необходимо написать ```#include <map>```.
