---
layout: topic
title: "STL-контейнеры: карта, множество, мультимножество"
permalink: topics/containers/
---

## Карты ##

### Базовая информация ###

Карта(ассоциативный массив, ```map```) - структура данных, которая позволяет нам выполнять различные операции над парами (ключ, значение). В языке ```С++``` карты представлены в стандартной библиотеке шаблонов.

### Ассимтотическая сложность ###

* Вставка ключа, обновление значения ключа - $$O(logN)$$
* Удаление ключа - $$O(logN)$$
* Поиск по ключу - $$O(logN)$$
* Поиск по значению - $$O(N)$$(необходимо итерироваться, пока не будет найдено необходимое значение).
* Количество различных ключей на текущий момент - $$O(1)$$

Не стоит забывать про константы в оценке ассимптотики: при одних и тех же значениях $$N$$ алгоритм бинарного поиска с той же ассимптотической сложностью будет работать напорядок быстрее карты. Это происходит из-за особенностей реализации карт в ```c++```.

### Использование ###

Решим простую задачу, используя ```map```:

Дана строка $$s$$ из $$n$$ слов. Необходимо вывести наиболее часто встречающееся слово и количество его вхождений в стрку.
{% highlight cpp linenos %}
#include <bits/stdc++.h>

using namespace std;

//Объявление карты: map<t1, t2>.
//t1 - тип ключа
//t2 - тип значения
map<string, int> cnt;
int n;
string s;

//compare определяет слово с большим числом вхождений
pair<string, int> compare (pair<string, int> w1, pair<string, int> w2)
{
	if (w1.second >= w2.second)
		return w1;
	return w2;
}

int main ()
{
	cin >> n;
	for (int i = 0; i < n; i ++)
	{
		cin >> s;
		//Подсчет количества вхождений каждого слова
		cnt[s] ++;
	}
	pair<string, int> mostCommontWord = *cnt.begin ();
	//Итерирование по карте:
	//обход производится в порядке возрастания ключей
	for (pair<string, int> i : cnt)
		mostCommontWord = compare (mostCommontWord, i);
	//Вывод ключа, т.е. самого слова
	cout << mostCommontWord.first << ' ';
	//Вывод числа вхождений
	cout << mostCommontWord.second << endl;
}
{% endhighlight %}

## Множества ##

Множество(```set```) - структура данных, предназначенная для управления элементами по значению.

Свойства множеств, которые важны для решения олимпиадных задач:
* Элементы во множестве хранятся в отсортированном по возрастанию виде.
* Множество хранит только одно вхождения любого элемента(в отличие от мультимножества).

Большинство операций с множествами с ```С++``` имеют сложность порядка $$O(logN)$$ операций, однако так же не стоит забывать про константу, которая эквивалентна константе ```map```.

### Основные операции и ассимптотическая сложность ###

* Вставка элемента - $$O(logN)$$
* Поиск элемента - $$O(logN)$$
* Удаление элемента - $$O(logN)$$
* Текущий размер(количество элементов) - $$O(1)$$

### Использование ###

Решим простую задачу, используя множество:

Дан массив $$a$$ из $$n(n \le 10^5)$$ чисел $$a(a_i \le 10^9)$$. Необходимо вывести количество различных элементов в данном массиве.

{% highlight cpp linenos %}
#include <bits/stdc++.h>

using namespace std;

//Объявление множества:
//set<type>, где type - тип элементов
set<int> s;

int main(){
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        //Вставка элементов массива во множество
		s.insert(x);
	}
	//Вывод размера множества,
	//т.е. количества различных элементов в нем
    cout << s.size();
}
{% endhighlight %}

## Мультимножества ##

Мультимножество(```multiset```) обладает теми же свойствами, что и обычное множество, за исключением того, что один элемент может входить в мультимножество несколько раз.

## Структуры на хэш-таблицах

Для всех описанных выше структур данных существуют их аналоги с префиксом unordered_(неупорядоченный). Отличие их состоит в том, что они реализованы с использованием хэш-таблиц, а значит ассимтотическая сложность операций с ними порядка O(1)(в среднем), однако константа еще больше, чем в упорядоченных структурах, указанных выше. Неупорядоченность проявляется в том, например, что элементы ```unordered_map``` при итерировании не обходятся в порядке возрастания ключей. Это стоит учитывать при решении задач, где лишний логарифм в ассимптотике может быть критичен.

## Подключение библиотек

Если вы по какой-то причине не используете ```bits/stdc++.h```, то все упомянутые выше структуры данных находятся в одноименных библиотеках. Т.е. для использования ```map``` необходимо подключить библиотеку ```#include <map>```.
