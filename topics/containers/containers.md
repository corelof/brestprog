---
layout: topic
title: "STL-контейнеры: карта, множество, мультимножество"
permalink: topics/containers/
---

## Карты ##

### Базовая информация ###

Карта(ассоциативный массив, мапы) - структура данных, которая позволяет нам выполнять различные операции над парами (ключ, значение). В языке ```С++``` карты представлены в стандартной библиотеке шаблонов.

Основные операции, выполняемые с мапами:
* Поиск элемента по его ключу
* Удаление ключа
* Вставка элемента
* Количество различных ключей на текущий момент

### Ассимтотическая сложность ###

* Вставка - $$O(logN)$$
* Удаление - $$O(logN)$$
* Поиск по ключу - $$O(logN)$$
* Поиск по значению - $$O(N)$$(необходимо итерироваться, пока не будет найдено необходимое значение).

Вроде бы неплохо, но есть одно но: в ассимтотике не принято писать константы, даже если они довольно ощутимы. Так вот, реальная ассимтотика мап это порядка $$O(5logN)$$. Не следует забывать про это, так как именно из-за этого некоторые решения могут получать TL. Кроме того, это является решающим фактором в случае выбора между алгоритмом бинарного поиска и использованием мапы.

### Использование ###

Решим простую задачу, используя мапу:

Дана строка $$s$$. Для каждой такой строки $$t$$ вывести количество ее вхождений в $$s$$ в качестве подстроки(если оно ненулевое).

{% highlight cpp linenos %}
//Мапа требует подключения библиотеки map, которая включена в bits/stdc++.h
#include <bits/stdc++.h>

using namespace std;

map<string, int> cnt; //Объявление мапы: map<type1, type2>, где type1 это тип ключа, а type2 - тип значения

int main(){
    string s;
    cin >> s;
    for (int l = 0; l < s.size(); l++) {
        string current = "";//Текущая собранная подстрока
        for (int r = l; r < s.size(); r++) {
            current.push_back(s[r]);//Обновление текущей строки новым символом
            cnt[current]++;//Пересчитываем количество вхождений
        }
    }
    for (auto i : cnt)//итерирование по мапе: i в данном случае является парой pair<type1, type2>, type соответствует тому, что был описан при создании мапы 
        cout << i.first << ' ' << i.second << "\n"; //В i.first находится ключ, в i.second находится значение
    //При использовани  мапы, обход будет совершаться в порядке возрастания ключей(в случае со строками - в лексикографическом порядке)
}
{% endhighlight %}

## Множества ##

Множество(сет) - структура данных, предназначенная для управления элементами по значению.

Свойства множеств, которые важны для решения олимпиадных задач:
* Элементы во множестве хранятся в отсортированном по возрастанию виде.
* Множество хранит только одно вхождения любого элемента(в отличие от мультимножества).

Большинство операций с множествами с ```С++``` имеют сложность порядка $$O(logN)$$ операций, однако не стоит забывать про всё ту же константу, которая приблизительно равна $$5$$.

### Основные операции и ассимптотическая сложность ###

* Вставка элемента - $$O(logN)$$
* Поиск элемента - $$O(logN)$$
* Удаление элемента - $$O(logN)$$
* Текущий размер(количество элементов) - $$O(1)$$

### Использование ###

Решим простую задачу, используя множество:

Дан массив $$a(a_i \le 10^9)$$ длины $$n(n \le 10^5)$$. Необходимо вывести количество различных элементов в данном массиве.

{% highlight cpp linenos %}
//Множество требует подключения библиотеки set, которая включена в bits/stdc++.h
#include <bits/stdc++.h>

using namespace std;

set<int> s;//Объявление множества: в треугольных скобках указывается тип элементов

int main(){
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        s.insert(x);//вставка всех элементов во множестве
    }
    cout << s.size();//вывод количества элементов во множестве, т.е. количества различных
}
{% endhighlight %}

## Мультимножества ##

Мультимножества(```multiset```) обладают теми же свойствами, что и обычные множества, за исключением того, что один элемент может входить в мультимножество несколько раз.

## Структуры на хэш-таблицах

Для всех описанных выше структур данных существуют их аналоги с префиксом unordered_(неупорядоченный). Отличие их состоит в том, что они реализованы с использованием хэш-таблиц, а значит ассимтотическая сложность операций с ними порядка O(1)(амортизировано). В случае с ```unordered_map```, при итерировании не будет соблюдаться порядок возрастания ключей. Это стоит учитывать при решении задач, где лишний логарифм в ассимптотике может быть критичен.
