---
layout: topic
title: "Контейнеры: map, set, multiset"
permalink: topics/containers/
---

## std::map (ассоциативный массив) ##

Ассоциативный массив - структура данных, которая позволяет нам выполнять различные операции
над парами (ключ, значение). В С++ ассоциативные массивы представлены в стандартной библиотеке
классом `std::map`.

Основные операции, выполняемые с `map`, и их сложность:
* Вставка элемента -- $$O(\log N)$$
* Поиск элемента по его ключу -- $$O(\log N)$$
* Удаление элемента -- $$O(\log N)$$
* Количество различных элементов в данный момент -- $$O(1)$$.

Стоит помнить, что асимптотическая сложность -- по сути теоретический параметр, а на практике
разница между временем работы разных операций одинаковой сложности может быть очень ощутима.
В случае `map`, операции сложностью $$O(\log N)$$ работают гораздо медленнее, чем, например,
бинарный поиск, и при решении задач об этом необходимо помнить.

### Использование ###

Решим простую задачу, используя `map`:

> Дана строка $$s$$. Для каждой такой строки $$t$$ вывести количество
> ее вхождений в $$s$$ в качестве подстроки (если оно ненулевое).

{% highlight cpp linenos %}
//Мапа требует подключения библиотеки map, которая включена в bits/stdc++.h
#include <bits/stdc++.h>

using namespace std;

map<string, int> cnt; //Объявление мапы: map<type1, type2>, где type1 это тип ключа, а type2 - тип значения

int main(){
    string s;
    cin >> s;
    for (int l = 0; l < s.size(); l++) {
        string current = "";//Текущая собранная подстрока
        for (int r = l; r < s.size(); r++) {
            current.push_back(s[r]);//Обновление текущей строки новым символом
            cnt[current]++;//Пересчитываем количество вхождений
        }
    }
    for (auto i : cnt)//итерирование по мапе: i в данном случае является парой pair<type1, type2>, type соответствует тому, что был описан при создании мапы 
        cout << i.first << ' ' << i.second << "\n"; //В i.first находится ключ, в i.second находится значение
    //При использовани  мапы, обход будет совершаться в порядке возрастания ключей(в случае со строками - в лексикографическом порядке)
}
{% endhighlight %}

## Множества ##

Множество(сет) - структура данных, предназначенная для управления элементами по значению.

Свойства множеств, которые важны для решения олимпиадных задач:
* Элементы во множестве хранятся в отсортированном по возрастанию виде.
* Множество хранит только одно вхождения любого элемента(в отличие от мультимножества).

Большинство операций с множествами с ```С++``` имеют сложность порядка $$O(logN)$$ операций, однако не стоит забывать про всё ту же константу, которая приблизительно равна $$5$$.

### Основные операции и ассимптотическая сложность ###

* Вставка элемента - $$O(logN)$$
* Поиск элемента - $$O(logN)$$
* Удаление элемента - $$O(logN)$$
* Текущий размер(количество элементов) - $$O(1)$$

### Использование ###

Решим простую задачу, используя множество:

Дан массив $$a(a_i \le 10^9)$$ длины $$n(n \le 10^5)$$. Необходимо вывести количество различных элементов в данном массиве.

{% highlight cpp linenos %}
//Множество требует подключения библиотеки set, которая включена в bits/stdc++.h
#include <bits/stdc++.h>

using namespace std;

set<int> s;//Объявление множества: в треугольных скобках указывается тип элементов

int main(){
    int n, x;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> x;
        s.insert(x);//вставка всех элементов во множестве
    }
    cout << s.size();//вывод количества элементов во множестве, т.е. количества различных
}
{% endhighlight %}

## Мультимножества ##

Мультимножества(```multiset```) обладают теми же свойствами, что и обычные множества, за исключением того, что один элемент может входить в мультимножество несколько раз.

## Структуры на хэш-таблицах

Для всех описанных выше структур данных существуют их аналоги с префиксом unordered_(неупорядоченный). Отличие их состоит в том, что они реализованы с использованием хэш-таблиц, а значит ассимтотическая сложность операций с ними порядка O(1)(амортизировано). В случае с ```unordered_map```, при итерировании не будет соблюдаться порядок возрастания ключей. Это стоит учитывать при решении задач, где лишний логарифм в ассимптотике может быть критичен.
